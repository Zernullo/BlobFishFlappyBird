import java.awt.*;
import java.awt.event.ActionEvent;      //A semantic event which indicates that a component-defined action occurred.
import java.awt.event.ActionListener;   //The listener interface for receiving action events.
import java.awt.event.KeyEvent;         //This event is generated by a component object when a key is pressed, released, or typed.
import java.awt.event.KeyListener;      //The listener interface for receiving keyboard events (keystrokes)
import java.util.ArrayList;             //Resizable-array implementation of the List interface. Provides methods to manipulate the size of the array
import java.util.Random;                //An instance of this class is used to generate a stream of pseudorandom numbers;
import javax.swing.*;                   //Typical Swing applications do processing in response to an event generated from a user gesture.

public class BlobFish extends JPanel implements ActionListener, KeyListener{

    int width = 568;
    int height = 850;

    //Images
    Image backgroundImage;
    Image fishImage;
    Image bottomPipeImage;
    Image topPipesImage;



    //Fish size(width,height) and position(x,y) on the frame
    int fishx = width/8;
    int fishy = height/2;
    int fishWidth = 50;
    int fishHeight = 50;



    //Class of Fish
    //A class is like a blueprint or template that defines what an object is and what it can do. It’s a way to organize and reuse code
    class Fish{
        int x = fishx;
        int y = fishy;
        int width = fishWidth;
        int height = fishHeight;
        Image img;

        Fish(Image img){
            this.img = img;
        }
    }



    //Pipes size(width,height) and position(x,y) on the frame
    int pipeX = width;
    int pipeY = 0;
    int pipeWidth = 64;
    int pipeHeight = 512;



    //Class of Pipe
    //A class is like a blueprint or template that defines what an object is and what it can do. It’s a way to organize and reuse code
    class Pipe{
        int x = pipeX;
        int y = pipeY;
        int width = pipeWidth;
        int height = pipeHeight;
        Image img;
        boolean passed = false;

        Pipe(Image img){
            this.img = img;
        }
    }



    //Games logic:
    //-y = moving up
    //+y = moving down
    //-x = moving backward
    //+x = moving forward
    Fish fish;
    int velocityX = -4; //moving backward(left)
    int velocityY = 0;  //moving up, set this to 0, so game will start falling down, but keyPressed method move it up
    int gravity = 1;    //bascially +y, move the bird down



    ArrayList<Pipe> pipes;          //Stores the pipe each time a new pipe in generated
    @SuppressWarnings("unused")
    Random random = new Random();   //Import the class Random - a method in its library



    Timer gameloop;         //Loop the game, basically keeps the game running
    Timer placePipesTimer;  //Generate new pipe base off time, Ex. Generate a pipe each 2 second


    boolean gameStarted = false;//When game starts set fish in position first and once space is press game starts
    boolean gameOver = false;   //Determine if the game is over
    boolean gameReset = false;  //Reset the fish before the game start again
    double score = 0;           //Keep track of the score



    //A Constructor - is a special function that initializes an object with predefined values when it is created.
    BlobFish() {
        setPreferredSize(new Dimension(width, height));
        setFocusable(true);
        

        //load images
        backgroundImage = new ImageIcon(getClass().getResource("background.png")).getImage();
        fishImage = new ImageIcon(getClass().getResource("Blobfish.png")).getImage();
        bottomPipeImage = new ImageIcon(getClass().getResource("bottomPipe.png")).getImage();
        topPipesImage = new ImageIcon(getClass().getResource("topPipe.png")).getImage();
        
        //fish
        fish = new Fish(fishImage);


        //Stores new generate pipe
        pipes = new ArrayList<>();
        //place pipes timer
        placePipesTimer = new Timer(1500, (ActionEvent e) -> { //Create a pipe every 2 second
            PlacePipes();
            repaint();
        });
        placePipesTimer.start();


        //game timer
        gameloop = new Timer(1000/60, this);
        gameloop.start();

         setupKeyListener();
    }

    // Method to set up key listener
    private void setupKeyListener() {
        addKeyListener(this);
    }


    
    public void PlacePipes(){
        //Face Down Pipe
        //Up pipe
        //PipeHeight/4 = 225
        //PipeY = 0
        //Math.random return 0-1, multiplying it by height/2=450, so random return between 0-450
        //0 - 225 - (0->450)[random number between 0->450]
        //Gives the height of the pipe in random
        int randomPipeY = (int)(pipeY - pipeHeight/4 - Math.random()*(pipeHeight/2));        
        Pipe topPipe = new Pipe(topPipesImage);
        topPipe.y = randomPipeY;
        pipes.add(topPipe);
        
        
        //Spaces between top and bottom pipe
        int openingSpace = height/4;

        //Face up pipe
        //Bottom pipe
        Pipe downPipe = new Pipe(bottomPipeImage);
        //0 + (pipe height) + (Space between top and bottom pipe)
        //Basically the y position of the Face up pipe (bottom pipe)
        downPipe.y = topPipe.y + pipeHeight + openingSpace; 
        pipes.add(downPipe);
    }


    //Allows images to show up on the frame
    @Override
    public void paint(Graphics g){
        super.paintComponent(g);
        draw(g);
    }

    //a method that allows paint to work
    public void draw(Graphics g){
        //background
        g.drawImage(backgroundImage, 0, 0, width, height, null);

        //fish
        g.drawImage(fish.img, fish.x, fish.y, fish.width, fish.height, null);

        //pipes
        for (int i = 0; i < pipes.size(); i++) {
            Pipe pipe = pipes.get(i);
            g.drawImage(pipe.img, pipe.x, pipe.y, pipe.width, pipe.height, null);
        }

        //scores
        g.setColor(Color.white);
        g.setFont(new Font("Arial", Font.PLAIN, 32));
        if(gameOver){
            g.drawString("Game Over: " + String.valueOf((int) score), 10, 35);
        }
        else{
            g.drawString(String.valueOf((int) score), 10, 35);
        }
    }

    //Fish movement
    public void move(){
        //fish
        if (!gameStarted) return;
        velocityY += gravity;//prevent bird from continously moving up
        fish.y += velocityY;//move up
        fish.y = Math.max(fish.y, 0);//prevent fish from moving out of the screen in y coordinate (0 is the very top of the screen)
        
        //pipes - counting system
        for (int i = 0; i < pipes.size(); i++) {
            Pipe pipe = pipes.get(i);
            pipe.x += velocityX;

            if(!pipe.passed && fish.x > pipe.x + pipe.width){
                pipe.passed = true;
                score += 0.5; //0.5 because there are 2 pipes, so 0.5*2 = 1, 1 point for each set of pipe
            }

            if(collision(fish, pipe)){
                gameOver = true;
            }
        }
        
        
        
        //top window y = 0 as it goes down the window y increases, so when fish hit the bottom of window game stops, it should be > height of y
        if(fish.y > height){
            gameOver = true;
        }

    }

    //Start the game and call methods to allow the game visual to look normal
    @Override
    public void actionPerformed(ActionEvent e) {
        move();
        repaint();

        //If gameOver is true, if statement will execute
        //If gameOver is false, if statement code will be skipped/ignore
        if(gameOver){
            placePipesTimer.stop();
            gameloop.stop();

        }
    }
    

    //If fish collide with the pipe
    private boolean collision(Fish a, Pipe b){
        return  a.x < b.x + b.width &&  //a's top left corner doesn't reach b's top right corner
                a.x + a.width > b.x &&  //a's top right corner doesn't reach b's top left corner
                a.y < b.y + b.height && //a's top left corner doesn't reach b's bottom left corner
                a.y + a.height > b.y;   //a's bottom left corner doesn't reach b's top left corner
    }

    //Once space press, fish jumps
    @Override
    public void keyPressed(KeyEvent e) {
        if(e.getKeyCode() == KeyEvent.VK_SPACE){//Basically every time space is pressed, fish goes up
            if (!gameStarted) {
                gameStarted = true; // Start the game on the first space press
                velocityY = -13; // Apply the jump immediately
            }
            else if (gameOver && !gameReset) { //(reset the variable to it initial value)
                // First space press resets fish position and variables but does not start the game
                fish.y = height / 2; //Reset the fish back to the middle
                velocityY = 0;
                pipes.clear();
                score = 0;
                gameReset = true;  // Mark game as reset but not started yet
                gameloop.start();
            }
            else if(gameOver){
                //restart the game 
                gameOver = false;
                gameReset = false;
                gameloop.start();
                placePipesTimer.start();
            }
            else{
                velocityY = -13;
            }
        }
    }
    @Override
    public void keyTyped(KeyEvent e) {}//Not going to be using KeyTyped

    @Override
    public void keyReleased(KeyEvent e) {}//Not going to be using KeyReleased
}
